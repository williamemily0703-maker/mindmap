<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mindmap từ văn bản – gõ để vẽ</title>
<style>
  /* Giữ nguyên style cũ và bỏ các nút không cần */
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="toolbar">
      <h1>Mindmap từ văn bản</h1>
      <button class="btn" id="btnExportData">Lưu mindmap</button>
      <button class="btn" id="btnImportData">Nhập mindmap</button>
      <button class="btn" id="btnZoomIn">+</button>
      <button class="btn" id="btnZoomOut">-</button>
    </div>
    <div class="help">
      • Mỗi dòng là một nút, số dấu cách đầu dòng = cấp độ.<br>
      • Màu nền nhạt dần theo cấp, mỗi nhánh chính màu khác nhau.<br>
    </div>
    <textarea id="editor" spellcheck="false"></textarea>
  </div>
  <div class="right" id="viewport">
    <div class="canvas" id="canvas">
      <svg class="svg-layer" id="wires"></svg>
    </div>
  </div>
</div>
<script>
const editor = document.getElementById('editor');
const canvas = document.getElementById('canvas');
const wires = document.getElementById('wires');
const viewport = document.getElementById('viewport');
const btnExportData = document.getElementById('btnExportData');
const btnImportData = document.getElementById('btnImportData');
const btnZoomIn = document.getElementById('btnZoomIn');
const btnZoomOut = document.getElementById('btnZoomOut');
let zoomLevel = 1;

const rootColors = ["hsl(200 85% 40%)","hsl(0 85% 45%)","hsl(120 70% 40%)","hsl(280 70% 50%)","hsl(40 90% 45%)"];

editor.addEventListener('keydown', e => {
  if (e.key === 'Tab') {
    e.preventDefault();
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
    editor.selectionStart = editor.selectionEnd = start + 2;
    triggerUpdate();
  }
});

function parseLines(text) {
  return text.split(/\r?\n/)
    .map((raw, idx) => {
      const match = raw.match(/^(\s*)(.*)$/);
      const spaces = match ? match[1].replace(/\t/g, '  ') : '';
      return { id: idx, level: spaces.length, text: (match ? match[2] : raw).trim() };
    })
    .filter(n => n.text.length > 0);
}

function buildTree(nodes) {
  const root = { id: 'root', level: -1, text: '', children: [] };
  const stack = [root];
  nodes.forEach(n => {
    while (stack.length && stack[stack.length - 1].level >= n.level) stack.pop();
    const parent = stack[stack.length - 1] || root;
    const node = { ...n, children: [] };
    parent.children.push(node);
    stack.push(node);
  });
  return root;
}

function layoutTree(root) {
  let y = 28;
  const positions = new Map();
  function measure(node) {
    const lines = Math.ceil((node.text.length + 1) / 26);
    return 18 * Math.max(1, lines) + 16;
  }
  function walk(node) {
    if (node.id !== 'root') {
      const x = node.level * 300 + 40;
      const h = measure(node);
      positions.set(node.id, { x, y, w: 220, h, level: node.level });
      y += h + 28;
    }
    node.children.forEach(walk);
  }
  root.children.forEach(walk);
  return { positions };
}

function hslForLevel(level, rootIndex) {
  const base = rootColors[rootIndex % rootColors.length];
  const light = Math.max(30, 90 - level * 10);
  return base.replace(/\d+%\)$/,(m)=>`${light}%)`);
}

function draw(root, layout) {
  const { positions } = layout;
  wires.innerHTML = '';
  [...canvas.querySelectorAll('.node')].forEach(n => n.remove());
  root.children.forEach((branch, idx) => render(branch, null, idx));

  function render(node, parent, rootIdx) {
    if (node.id !== 'root') {
      const p = positions.get(node.id);
      const el = document.createElement('div');
      el.className = 'node';
      el.style.position = 'absolute';
      el.style.left = (p.x * zoomLevel) + 'px';
      el.style.top = (p.y * zoomLevel) + 'px';
      el.style.width = (p.w * zoomLevel) + 'px';
      el.style.background = hslForLevel(node.level, rootIdx);
      el.textContent = node.text;
      canvas.appendChild(el);
      if (parent && parent.id !== 'root') {
        const a = positions.get(parent.id);
        const x1 = a.x * zoomLevel + a.w * zoomLevel;
        const y1 = a.y * zoomLevel + a.h / 2 * zoomLevel;
        const x2 = p.x * zoomLevel;
        const y2 = p.y * zoomLevel + p.h / 2 * zoomLevel;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', `M ${x1} ${y1} C ${(x1+x2)/2} ${y1}, ${(x1+x2)/2} ${y2}, ${x2} ${y2}`);
        path.setAttribute('stroke', '#888');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-width', 2);
        wires.appendChild(path);
      }
    }
    node.children.forEach(child => render(child, node, rootIdx));
  }
}

function triggerUpdate() {
  const nodes = parseLines(editor.value);
  const tree = buildTree(nodes);
  draw(tree, layoutTree(tree));
}

btnZoomIn.onclick = () => { zoomLevel *= 1.2; triggerUpdate(); };
btnZoomOut.onclick = () => { zoomLevel /= 1.2; triggerUpdate(); };

btnExportData.onclick = () => {
  const data = { text: editor.value };
  const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'mindmap.json';
  a.click();
};

btnImportData.onclick = () => {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = '.json';
  inp.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const obj = JSON.parse(reader.result);
      editor.value = obj.text || '';
      triggerUpdate();
    };
    reader.readAsText(file);
  };
  inp.click();
};

editor.addEventListener('input', triggerUpdate);
triggerUpdate();
</script>
</body>
</html>
